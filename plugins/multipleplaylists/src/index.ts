import { LunaUnload, Tracer } from "@luna/core";
import { MediaItem, redux, ContextMenu, Playlist } from "@luna/lib";

export const { trace, errSignal } = Tracer("[MultiplePlaylists]");

// plugin settings
export { Settings } from "./Settings";

// Functions in unloads are called when plugin is unloaded.
export const unloads = new Set<LunaUnload>();

// Function to show playlist selector modal
async function showPlaylistSelector(song: MediaItem) {

    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;

    // Create modal content
    const modal = document.createElement('div');
    modal.style.cssText = `
        background: var(--background-color, #1a1a1a);
        border-radius: 8px;
        padding: 24px;
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        color: var(--text-color, white);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    `;

    // Get song details
    const songTitle = song.title ? await song.title() : 'Unknown Song';
    let songArtist = 'Unknown Artist';
    
    // Try to get artist information
    try {
        if (song.artist) {
            const artist = await song.artist();
            if (artist && artist.name) {
                songArtist = artist.name;
            }
        } else if (song.artists) {
            const artists = await song.artists();
            if (artists && artists.length > 0) {
                // Get the first artist
                const firstArtist = await artists[0];
                if (firstArtist && firstArtist.name) {
                    songArtist = firstArtist.name;
                }
            }
        }
    } catch (error) {
        // Log artist info errors but don't fail the operation
        trace.warn("Could not get artist information:", error);
        songArtist = 'Unknown Artist';
    }

    modal.innerHTML = `
        <h2 style="margin: 0 0 16px 0; font-size: 18px;">Add to Multiple Playlists</h2>
        <div style="margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 4px;">
            <div style="font-weight: 500;">${songTitle}</div>
            <div style="font-size: 14px; opacity: 0.7;">${songArtist}</div>
        </div>
        <p style="margin: 0 0 16px 0; opacity: 0.7;">Select playlists to add this song to:</p>
        <div id="playlist-list" style="margin-bottom: 20px;"></div>
        <div style="display: flex; gap: 12px; justify-content: flex-end;">
            <button id="cancel-btn" style="
                padding: 8px 16px;
                background: transparent;
                border: 1px solid var(--border-color, #444);
                border-radius: 4px;
                color: var(--text-color, white);
                cursor: pointer;
            ">Cancel</button>
            <button id="add-btn" style="
                padding: 8px 16px;
                background: var(--primary-color, #007acc);
                border: none;
                border-radius: 4px;
                color: white;
                cursor: pointer;
            ">Add to Selected Playlists</button>
        </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    // Populate playlist list
    populatePlaylistList(song);

    // Event listeners
    const cancelBtn = modal.querySelector('#cancel-btn');
    const addBtn = modal.querySelector('#add-btn');

    cancelBtn?.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });

    addBtn?.addEventListener('click', () => {
        addToSelectedPlaylists(song);
        document.body.removeChild(overlay);
    });

    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
}

// Type definition for playlist object structure
interface PlaylistObject {
    uuid: string;
    title?: string;
    numberOfTracks?: number;
    type: string;
    isEditable?: boolean;
    isAutoGenerated?: boolean;
    isSuggested?: boolean;
    isRecommended?: boolean;
    creator?: {
        id?: string;
    };
}

// Function to populate the playlist list
async function populatePlaylistList(song?: MediaItem) {
    const playlistContainer = document.querySelector('#playlist-list');
    if (!playlistContainer) return;

    try {
        // Get playlists from redux store
        const state = redux.store.getState();
        const playlists = state.content?.playlists || {};
        const currentUser = state.auth?.user || {};

        if (Object.keys(playlists).length === 0) {
            playlistContainer.innerHTML = '<p style="opacity: 0.7;">No playlists found. Create some playlists first!</p>';
            return;
        }

        // Filter for user's own playlists more specifically
        const playlistsArray = Object.values(playlists).filter((playlist: any): playlist is PlaylistObject => {
            if (!playlist || playlist.type !== 'USER') return false;
            
            // Additional filtering to exclude recommended/suggested playlists
            // Check for properties that indicate ownership
            const playlistData = playlist as any;
            
            // Exclude playlists that are marked as suggested/recommended
            if (playlistData.isSuggested || playlistData.isRecommended) return false;
            
            // Only include playlists that are editable (user owns them)
            if (playlistData.isEditable === false) return false;
            
            // Exclude auto-generated playlists
            if (playlistData.isAutoGenerated) return false;
            
            // Additional check: if creator info is available, ensure it's the current user
            if (playlistData.creator?.id && currentUser.id && playlistData.creator.id !== currentUser.id) {
                return false;
            }
            
            return true;
        });
        
        console.log(`[MultiplePlaylists] Processing ${playlistsArray.length} user playlists for duplicate detection`);
        
        // Show loading state initially
        playlistContainer.innerHTML = '<div style="padding: 20px; text-align: center; opacity: 0.7;">Loading playlists...</div>';
        
        // Process playlists in batches to avoid blocking the UI
        const BATCH_SIZE = 5;
        const playlistBatches = [];
        for (let i = 0; i < playlistsArray.length; i += BATCH_SIZE) {
            playlistBatches.push(playlistsArray.slice(i, i + BATCH_SIZE));
        }
        
        // Clear container and start building the list
        playlistContainer.innerHTML = '';
        
        for (const [batchIndex, batch] of playlistBatches.entries()) {
            console.log(`[MultiplePlaylists] Processing batch ${batchIndex + 1}/${playlistBatches.length} (${batch.length} playlists)`);
            
            // Process batch with Promise.allSettled for fault tolerance
            const batchResults = await Promise.allSettled(
                batch.map(async (playlist: PlaylistObject) => {
                    try {
                        const isAlreadyInPlaylist = song ? await isSongInPlaylist(song, playlist.uuid) : false;
                        const statusText = isAlreadyInPlaylist ? ' (Already added)' : '';
                        const opacity = isAlreadyInPlaylist ? '0.6' : '1';
                        
                        return `
                            <label style="
                                display: flex;
                                align-items: center;
                                padding: 8px;
                                margin-bottom: 4px;
                                cursor: pointer;
                                border-radius: 4px;
                                transition: background 0.2s;
                                opacity: ${opacity};
                            " onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" 
                                       data-playlist-id="${playlist.uuid}" 
                                       style="margin-right: 12px; cursor: pointer;"
                                       ${isAlreadyInPlaylist ? 'disabled' : ''}>
                                <div>
                                    <div style="font-weight: 500;">${playlist.title || 'Untitled Playlist'}${statusText}</div>
                                    <div style="font-size: 12px; opacity: 0.7;">${playlist.numberOfTracks || 0} tracks</div>
                                </div>
                            </label>
                        `;
                    } catch (error) {
                        console.warn(`[MultiplePlaylists] Failed to process playlist ${playlist.uuid}:`, error);
                        // Return playlist without duplicate detection if check fails
                        return `
                            <label style="
                                display: flex;
                                align-items: center;
                                padding: 8px;
                                margin-bottom: 4px;
                                cursor: pointer;
                                border-radius: 4px;
                                transition: background 0.2s;
                            " onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" 
                                       data-playlist-id="${playlist.uuid}" 
                                       style="margin-right: 12px; cursor: pointer;">
                                <div>
                                    <div style="font-weight: 500;">${playlist.title || 'Untitled Playlist'} (Check failed)</div>
                                    <div style="font-size: 12px; opacity: 0.7;">${playlist.numberOfTracks || 0} tracks</div>
                                </div>
                            </label>
                        `;
                    }
                })
            );
            
            // Add results to UI immediately after each batch
            const batchHtml = batchResults
                .filter(result => result.status === 'fulfilled')
                .map(result => result.value)
                .join('');
            
            playlistContainer.innerHTML += batchHtml;
            
            // Small delay between batches to keep UI responsive
            if (batchIndex < playlistBatches.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        }
        
        console.log('[MultiplePlaylists] Finished processing all playlists');
        
    } catch (error) {
        // Log playlist load errors for debugging
        trace.warn("Error loading playlists:", error);
        playlistContainer.innerHTML = '<p style="color: #ff6b6b;">Error loading playlists</p>';
    }
}

// Cache for playlist contents to avoid re-loading
const playlistCache = new Map<string, Set<string>>();
const cacheTimestamps = new Map<string, number>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Clear cache periodically to prevent memory buildup
setInterval(() => {
    const now = Date.now();
    for (const [playlistId, timestamp] of cacheTimestamps.entries()) {
        if (now - timestamp > CACHE_DURATION) {
            playlistCache.delete(playlistId);
            cacheTimestamps.delete(playlistId);
        }
    }
}, 60000); // Clean every minute

// Function to check if a song is already in a playlist using Luna's Playlist API with optimizations
async function isSongInPlaylist(mediaItem: MediaItem, playlistId: string): Promise<boolean> {
    try {
        console.log(`[MultiplePlaylists] Checking if song ${mediaItem.id} is in playlist ${playlistId}`);
        
        const songIdStr = String(mediaItem.id);
        const now = Date.now();
        
        // Check cache first
        if (playlistCache.has(playlistId)) {
            const cacheTime = cacheTimestamps.get(playlistId) || 0;
            if (now - cacheTime < CACHE_DURATION) {
                const cachedTracks = playlistCache.get(playlistId)!;
                const isInPlaylist = cachedTracks.has(songIdStr);
                console.log(`[MultiplePlaylists] Cache hit for playlist ${playlistId}: ${isInPlaylist ? 'IS' : 'NOT'} in playlist`);
                return isInPlaylist;
            } else {
                // Cache expired, clear it
                playlistCache.delete(playlistId);
                cacheTimestamps.delete(playlistId);
            }
        }
        
        // Add timeout protection for very large playlists (30 seconds max)
        const timeoutPromise = new Promise<boolean>((_, reject) => {
            setTimeout(() => reject(new Error('Playlist check timeout')), 30000);
        });
        
        const checkPromise = async (): Promise<boolean> => {
            // Load the playlist using Luna's Playlist API
            const playlist = await Playlist.fromId(playlistId);
            if (!playlist) {
                console.log(`[MultiplePlaylists] Could not load playlist ${playlistId}`);
                return false;
            }
            
            console.log(`[MultiplePlaylists] Successfully loaded playlist: ${await playlist.title()}`);
            
            // Get all media items in the playlist and cache them
            const playlistMediaItems = await playlist.mediaItems();
            const trackIds = new Set<string>();
            let processedCount = 0;
            
            // Convert async generator to Set for fast lookups with progress logging
            for await (const playlistMediaItem of playlistMediaItems) {
                trackIds.add(String(playlistMediaItem.id));
                processedCount++;
                
                // Log progress for very large playlists
                if (processedCount % 1000 === 0) {
                    console.log(`[MultiplePlaylists] Processed ${processedCount} tracks from playlist ${playlistId}...`);
                }
            }
            
            // Cache the results
            playlistCache.set(playlistId, trackIds);
            cacheTimestamps.set(playlistId, now);
            
            const isInPlaylist = trackIds.has(songIdStr);
            console.log(`[MultiplePlaylists] Song ${songIdStr} ${isInPlaylist ? 'IS' : 'NOT'} in playlist (${trackIds.size} tracks total)`);
            
            return isInPlaylist;
        };
        
        // Race between the actual check and timeout
        return await Promise.race([checkPromise(), timeoutPromise]);
        
    } catch (error) {
        if (error instanceof Error && error.message === 'Playlist check timeout') {
            console.warn(`[MultiplePlaylists] Timeout checking playlist ${playlistId} - playlist may be very large, skipping duplicate check`);
        } else {
            console.error(`[MultiplePlaylists] Error checking playlist membership:`, error);
        }
        return false; // If we can't check, don't block the addition
    }
}

// Function to add song to selected playlists from the modal, and persist selection
async function addToSelectedPlaylists(song: MediaItem) {
    const checkboxes = document.querySelectorAll('#playlist-list input[type="checkbox"]:checked');
    const selectedPlaylistIds = Array.from(checkboxes).map((cb: any) => cb.dataset.playlistId).filter(Boolean);

    if (selectedPlaylistIds.length === 0) {
        showNotification('Please select at least one playlist', 'error');
        return;
    }

    try {
        const songTitle = song.title ? await song.title() : 'Unknown Song';
        let successCount = 0;
        let errorCount = 0;
        let skippedCount = 0;

        // Add to each selected playlist
        for (const playlistId of selectedPlaylistIds) {
            try {
                console.log(`[MultiplePlaylists] Processing playlist ${playlistId} for song ${song.id}`);
                
                // Check if song is already in the playlist using the MediaItem
                const alreadyInPlaylist = await isSongInPlaylist(song, playlistId);
                
                if (alreadyInPlaylist) {
                    skippedCount++;
                    console.log(`[MultiplePlaylists] Song "${songTitle}" already in playlist, skipping`);
                    continue;
                }
                
                console.log(`[MultiplePlaylists] Adding song "${songTitle}" to playlist ${playlistId}`);

                redux.store.dispatch({
                    type: 'content/ADD_MEDIA_ITEMS_TO_PLAYLIST',
                    payload: {
                        playlistUUID: playlistId,
                        mediaItemIdsToAdd: [song.id],
                        addToIndex: -1 // Add to end
                    }
                });
                successCount++;
            } catch (error) {
                // Log per-playlist errors but continue with others
                trace.warn(`Error adding to playlist ${playlistId}:`, error);
                errorCount++;
            }
        }

        // Log results to console only (TIDAL shows its own "Added to playlist" notification)
        console.log(`[MultiplePlaylists] Results for "${songTitle}": ${successCount} added, ${errorCount} failed, ${skippedCount} skipped`);
        
        // Only show notifications for errors/warnings, let TIDAL handle success notifications
        if (errorCount > 0) {
            let message = '';
            if (skippedCount > 0) {
                message = `"${songTitle}" added to ${successCount} playlist${successCount > 1 ? 's' : ''} (${errorCount} failed, ${skippedCount} already contained this song)`;
            } else {
                message = `"${songTitle}" added to ${successCount} playlist${successCount > 1 ? 's' : ''} (${errorCount} failed)`;
            }
            showNotification(message, 'warning');
        }

    } catch (error) {
        // Log outer add errors
        trace.err("Error adding song to playlists:", error);
        showNotification('Error adding song to playlists', 'error');
    }
}

// Function to show notification
function showNotification(message: string, type: 'success' | 'warning' | 'error') {
    // Log to console with appropriate level based on type
    switch (type) {
        case 'success':
            trace.msg.log(message);
            break;
        case 'warning':
            trace.warn(message);
            break;
        case 'error':
            trace.err(message);
            break;
    }
}

// Initialize plugin
function init() {
    // Log plugin initialization
    trace.msg.log("Multiple Playlists plugin initialized");
    
    // Add context menu integration
    setupContextMenuIntegration();
}

// Setup context menu integration for "Add to Multiple Playlists"
function setupContextMenuIntegration() {
    const contextMenuButton = (ContextMenu as any).addButton(unloads);
    contextMenuButton.text = "Add to Multiple Playlists";
    
    // Store the context menu song ID for use in onClick
    let contextMenuSongId: redux.ItemId | null = null;
    let contextMenuContentType: redux.ContentType = "track";
    
    contextMenuButton.onClick(async () => {
        // Close the context menu first
        redux.store.dispatch({ type: "contextMenu/CLOSE" });
        
        // Small delay to ensure context menu is closed
        setTimeout(async () => {
            if (contextMenuSongId) {
                // Get the actual MediaItem instance for the right-clicked song
                try {
                    const mediaItem = await MediaItem.fromId(contextMenuSongId, contextMenuContentType);
                    if (mediaItem) {
                        const title = await mediaItem.title();
                        await showPlaylistSelector(mediaItem);
                    } else {
                        showNotification('Could not load song information', 'error');
                    }
                } catch (error) {
                    // Log media item load errors
                    trace.warn("Error loading song information:", error);
                    showNotification('Error loading song information', 'error');
                }
            } else {
                showNotification("No song selected", "error");
            }
        }, 100);
    });
    
    // Only show the button for media item context menus and capture the song ID
    ContextMenu.onMediaItem(unloads, async ({ mediaCollection, contextMenu }) => {
        // Store the song ID from the context menu for later use
    try {
            // Handle different types of media collections
            if (mediaCollection && typeof mediaCollection === 'object') {
                // For MediaItems collections, get the first MediaItem
                if ('mediaItems' in mediaCollection && typeof mediaCollection.mediaItems === 'function') {
                    // This is an Album or Playlist
                    const mediaItemsGenerator = await mediaCollection.mediaItems();
                    for await (const mediaItem of mediaItemsGenerator) {
                        contextMenuSongId = mediaItem.id;
                        contextMenuContentType = mediaItem.contentType;
                        break; // We only need the first one
                    }
                } else {
                    // This might be MediaItems collection - try to iterate directly
                    for await (const mediaItem of mediaCollection as unknown as Iterable<MediaItem>) {
                        contextMenuSongId = mediaItem.id;
                        contextMenuContentType = mediaItem.contentType;
                        break; // We only need the first one
                    }
                }
            }
        } catch (error) {
            // Log context menu extraction errors
            trace.warn("Error extracting media item from context menu:", error);
            contextMenuSongId = null;
        }
        
        // Show our button in the context menu
    await contextMenuButton.show(contextMenu);
    });
}

// Start the plugin
init();